#include "Rocket.h"Rocket::Rocket(void)  :_targetRotation(0),_dr(0),_ar(0),_vr(0),_rotationSpring(0.1f),_rotationDamping(0.8f),_pivot(Point(-1,-1)),_rotationOrientation(ROTATE_NONE){}Rocket::~Rocket(void){}Rocket* Rocket::create () {	auto sprite = new Rocket();    	if (sprite && sprite->initWithSpriteFrameName("rocket.png")) {        sprite->reset();		sprite->setRadius(sprite->boundingBox().size.height * 0.5f);        sprite->autorelease();                return sprite;	}	CC_SAFE_DELETE(sprite);	return nullptr;}void Rocket::reset () {        _speed = 80;	_pivot = Vec2(-1,1);    _rotationOrientation = ROTATE_NONE;    this->setRotation(-90);	_targetRotation = -90;    float angle = CC_DEGREES_TO_RADIANS(this->getRotation());	_vector = Vec2 (_speed * cos( angle ), -_speed * sin( angle ));}			void Rocket::update (float dt) {    	Point position = this->getPosition();		if (_rotationOrientation == ROTATE_NONE) {        		position.x += _vector.x * dt;		position.y += _vector.y * dt;		} else {				//rotate point around a pivot by a certain amount (rotation angle)        float angle = _angularSpeed * dt;        Point rotatedPoint = position.rotateByAngle(_pivot, angle);        position.x = rotatedPoint.x;        position.y = rotatedPoint.y;                                 float rotatedAngle;                                 Point diff = position;        diff.subtract(_pivot);        Point clockwise = diff.getRPerp();                                  if (_rotationOrientation == ROTATE_COUNTER) {             rotatedAngle = atan2 (-1 * clockwise.y, -1 * clockwise.x);         } else {             rotatedAngle = atan2 (clockwise.y, clockwise.x);         }                  //update rocket vector         _vector.x = _speed * cos (rotatedAngle);         _vector.y = _speed * sin (rotatedAngle);                  this->setRotationFromVector();                  //wrap rotation values to 0-360 degrees         if (this->getRotation() > 0) {             this->setRotation( fmodf(this->getRotation(), 360.0f) );         } else {             this->setRotation( fmodf(this->getRotation(), -360.0f) );         }	}       if (_targetRotation > this->getRotation() + 180) {        _targetRotation -= 360;    }    if (_targetRotation < this->getRotation() - 180) {        _targetRotation += 360;    }    this->setPosition(position);        _dr = _targetRotation - this->getRotation() ;    _ar = _dr * _rotationSpring;    _vr += _ar ;    _vr *= _rotationDamping;    float rotationNow = this->getRotation();    rotationNow += _vr;    this->setRotation(rotationNow);}void Rocket::select(bool flag) {    if (flag) {        this->setDisplayFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("rocket_on.png"));    } else {        this->setDisplayFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("rocket.png"));    }}bool Rocket::collidedWithSides() {        Size screenSize = Director::getInstance()->getWinSize();            if (_position.x > screenSize.width - _radius) {        _position.x =  screenSize.width - _radius;        _rotationOrientation = ROTATE_NONE;        _vector = Vec2(this->getVector().x * -1, this->getVector().y);        this->setRotationFromVector();        return true;    }        if (_position.x < _radius) {        _position.x =  _radius;       	_rotationOrientation =  ROTATE_NONE;        _vector =  Vec2 (this->getVector().x * -1, this->getVector().y);        this->setRotationFromVector();        return true;            }        if (_position.y < _radius) {        _position.y = _radius;       	_rotationOrientation = ROTATE_NONE;        _vector =  Vec2 (this->getVector().x, this->getVector().y * -1);        this->setRotationFromVector();        return true;    }        if (_position.y > screenSize.height - _radius) {        _position.y =  screenSize.height - _radius;       	_rotationOrientation = ROTATE_NONE;        _vector =  Vec2 (this->getVector().x, this->getVector().y * -1);        this->setRotationFromVector();        return true;    }        return false;}